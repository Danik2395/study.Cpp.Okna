# Лабораторные

## 1. Рекурсия
						
**Вариант 12:** Вычислить произведение четного количества n (n > 2) сомножителей следующего вида: Y = (²⁄₁ · ²⁄₃) · (⁴⁄₃ · ⁴⁄₅) · (⁶⁄₅ · ⁶⁄₇)

- [Код](Lab1WIndow.cpp)

По умолчанию поставит 2 множителя. Даёт ввести только одно число

## 2. Стек

**Вариант 12:** Созданный список разделить на два: в первый поместить четные, а во второй – нечетные числа

- [Односвязный список](#singlenodelist)
- [Стек](#stack)
- [Применение](Lab2Window.cpp)

### Свободное значение:

Не влияет на удалене верхнего элемента и сортироку

**Пусто**
- Создать случайно
	- Выберет случайное число от 5 до 15 и создаст стек, состоящий из случайных чисел от -1000000 до 1000000, размером равный выбранному значению
- Добавить
	- Ничего не будет

**Одно число**
- Создать случайно
	- Создаст стек случайных чисел, размером равный введённому значению
- Добавить
	- Добавит введённое значение в стек

**Несколько чисел**
- Создать случайно
	- [Приведёт](#mainedit) числа к одному и создаст случайный стек
- Добавить
	- Добавит введённые числf в стек

**Очистить всё**
- Очистит поле ввода свободного значения и поле вывода

### Радио кнопки:
- По умолчанию выбрана кнопка "Общий"
	- При очистке всего будет выбрана она же
- При переключении с "Общий" на "Чётный" или "Нечётный" стек разделяется на чётную и нечётную части
- При переключении с "Чётный" или "Нечётный" на "Общиё" стек соединяется в один
	
**Общий**
- Все операции со стеком направлены на основной стек

**Чётный**
- Все операции со стеком направлены на чётную часть стека

**Нечётный**
- Все операции со стеком направлены на нечётную стека

# Настройки проекта

- Стандарт языка C++: ISO C++17 (/std:c++17)

## Манифест
- Поддержа высокого DPI

# Окна интерфейса

## Шаблоны

### [BaseWindow](BaseWindow.h)
- Первый в каскаде
- Создаёт окно и регистрирует класс
- "Кладёт" в окно указатель на его класс
- **pThis**
	- Легаси коду в `RegisterClass()` нужна конкретная сигнатура с 4-мя параметрами
	- Метод создаёт 5-й параметр `this`
	- Обходим это `static` на `WindowProc`
- Обрабатывает 
	- `MW_DESTROY` 
	- И вызывает `DefWindowProc` на дефолт свича

### [D2DWindow](D2DWindow.h)
- Наследуется от [`BaseWindow`](#basewindow)
- Добавляет Direct2D и DirectWrite
- Создаёт
	- `ID2D1Factory`
	- `ID2D1HwndRenderTarget`
	- `IDWriteFactory`
	- Объект класса [`DpiScale`](#dpiscale)
		- Макрос `S()` для скейла
- `CreateGraphicsResources()`
	- Вызывает `virtual CreateDeviceDepRec()` для создания ресурсов для конкретных окон
- `OnPaint`
	- Инициализирует рисование
	- И вызывает `DrawContent` для отрисовки реализованной в конкретных окнах
- Обрабатывает
	- `WM_PAINT`
	- `WM_CREATE`
	- `WM_SIZE`
	- И отдаёт дефолт в `BaseWindow`

### [MainWindow](MainWindow.h)
- Наследуется от [`D2DWindow`](#d2dwindow)
- Обрабатывает 
	- `WM_SETCURSOR`
	- И отдаёт дефолт в `MainWindow`
- Рисует шумный фон

---

## Вспомогательные классы и функции

### [DpiScale](DpiScale.h)
- Создаётся для каждого окна
	- Композиция
- Переводит DIPs в физические пиксели и наоборот
- Имеет `static` метод для скейла по дефолтным настройкам системы
	- Там, где окно ещё не создано

### [ThreadLauncher](ThreadLauncher.h) (**функция**)
- Создаёт новое окно заданного класса в отдельном потоке
	- В	случае,если сущностей окна не больше заданного числа
	- Свой цикл сообщений

### [WndProps](WndProps.h)
- Наследуется Parent окнами
	- В конструкторе окна вызывается конструктор `WndProps`
- Содержит для каждого окна
	- Размеры
	- Начальное положение
	- Имя
- "Перегрузка" для _дефолтного_ значения количества окон
	- Не добавялет логику проверки количества окон
	- Метод проверки возвращает 0
	- Конструкторы наследуются
- "Перегрузка" для _произвольного_ значения количества окон
	- Принимаемые конструктором параметры произвольного количества передаются в родительский конструктор

### [IControl](IControl.h)
- Чисто виртуальный класс
- Можно было и без него, но чтобы был `Move()` в каждом контроле

---

## Окна-контролы

Почему нет BaseControl?

Потому что для лабораторных это Овер инжиниринг. 
Вычленять, что у них там общее, и потом запоминать, 
какая же переменная была базовой, а какая нет, будет сложно.

### [MainButton](Mainbutton.h)
- Наследуется от 
	- [`D2DWindow`](#d2dwindow)
- Реализует
	- [`IControl`](#icontrol)
- Окно-кнопка
- Создаёт себя через `BaseWindow::Create()` с заданными параметрами
- Рисует
	- Себя
	- Текст
- Обрабатывает
	- `WM_SETCURSOR`
	- Одиночные нажатия
		- Отправляет сообщение о нажатии
		- "Кладёт" id в lowWord `wParam`

### [MainCheckBox](MainCheckBox.h)
- Наследуется от 
	- [`D2DWindow`](#d2dwindow)
- Реализует
	- [`IControl`](#icontrol)
- Окно-чекбокс
- Работает как кнопка, но имеет состояние `isSelected`

### [MainEdit](MainEdit.h)
- Реализует
	- [`IControl`](#icontrol)
- Обёртка для `EDIT` (Не Subclass)
- Создаёт
	- Окно класса `EDIT`
	- C заданными флагами стиля
	- С заданными параметрами
	- C текстом, [скейленым](#dpiscale) под DPI
- Может
	- `SetText()`
	- `GetText()`
	- `static GetNumber()` для получения чистого числа
		- Убирает не числа и собирает все числа в одно
- Нужен windows style `\r\n` для перехода на новую строку

### [MainRadioButton](MainRadioButton.h)
- Реализует
	- [`IControl`](#icontrol)
- Самый не Windows контрол
	- Всё есть окно. Окно есть прямоугольник. Кнопка круглая.
- GDI обрезка окна
	- Подогнано, чтобы не было видно рваного контура и была видна полезная область
	- Костыль, но сделать размытие по альфе на WS_CHILD сложнее
- Группа задаётся параметром в шаблоне
- Переделанный чекбокс
	- Так же отправляет сообщения на нажатии
		- А также перерисовывает предыдущую нажатую кнопку
	- Но имеет `static` поле с id нажатой кнопки
- Можно
	- Проверить не только состояние самой кнопки, но и какая кнопка сейчас нажата
	- Установить произвольную кнопку во включённое состояние

---

## Конкретные окна

### [HubWindow](HubWindow.h)
- Наследуется от 
	- [`MainWindow`](#mainwindow)
- Реализует
	- [`WndProps`](#wndprops)
- Расставляет кнопки для создания окон лабораторных

### Все окна Лабораторных
- Наследуется от 
	- [`MainWindow`](#mainwindow)
- Реализует
	- [`WndProps`](#wndprops)
- Кнопки
- Едиты
- Чекбоксы

# Контейнеры

## [my_random](my_random.h)
Не контейнер, но всё же

Чёто используют `std::mt19937` и `uniform_int_destrebution`, но оно всё длинное и избыточное. Поэтому _обёртка_ для XORshift64

Есть пара конструкторов
- Без параметров (ключ берётся из времени жизни системы)
- С ключом генерации
- С лимитами
- С ключом и лимитами

Также можно это всё поставить и не в конструкторе
- Реализован flow interface
- Можно поставить шанс минуса (по факту не минуса, а инвертации числа)

Есть пару перегрузок
- Оператора приведения к типу (**НЕ** проверяет численный ли тип)
- Оператора функции для случаев, когда компилятор не приводит типы

Удобно, быстро, шаблонно.

## [SingleNodeList](SingleNodeList.h)
- Типа STL (forward_list)
- Имеет итератор (пока только его)
	- `begin()`
	- `end()`
	- `operator*()`
	- `operator->()`
	- `operator==()`
	- `operator!=()`
- O(1) доступ к началу и концу
	- `front()`
	- `back()`
- Bubble sort перестановкой указателей
- Перегрузка копирования
	- `operator=()`

## [Stack](Stack.h)
- Тоже типа STL
	- Менее строгого типа
- Ограничивает возможности используемого контейнера
	- По умолчанию односвязный список
- Есть сортировка (приоритетный стек, что?)
- И `begin()`, `end()`